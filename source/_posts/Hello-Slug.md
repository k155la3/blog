title: Hello Slug
date: 2015-12-11 16:31:06
tags:
- Slug

thumbnailImage: thumb.jpg
thumbnailImagePosition: left
coverImage: cover.jpg
coverMeta: out
---
For a while I wanted to do DIY electronics project to dust off my early teenage passion. Ideally it would combine designing digital circuitry and writing software. Also to be within my modest abilities and yet fun to work on. Building a small computer using a CPU from the 80's seemed too boring. Building custom CPU from the ground up seemed way too complex. Until I saw [Nibbler](http://www.bigmessowires.com/category/nibbler/) by [Steve Chamberlin](http://www.bigmessowires.com/). After studying Steve's design for few weeks I had an idea of building a CPU of similar complexity that would be an improvement on Nibbler in being more fun to program. Meet Slug. Slug project is inspired, informed and influenced by Nibbler. Here are major goals I have in mind:

* Use bare [ALU](https://en.wikipedia.org/wiki/Arithmetic_logic_unit), [EEPROM](https://en.wikipedia.org/wiki/EEPROM) and [SRAM](https://en.wikipedia.org/wiki/Static_random-access_memory) plus [sequential logic](https://en.wikipedia.org/wiki/Sequential_logic) for registers and counters;
* Use least number of [integrated circuits](https://en.wikipedia.org/wiki/Integrated_circuit) (ICs) and as few wires as possible;
* Yet support 16-bit arithmetic and addressing;
* And have functional instruction that includes [register indirect](https://en.wikipedia.org/wiki/Addressing_mode#Register_indirect_2) addressing for data and code;
* Support IO devices: small [LCD screen](http://www.hantronix.com/page/index/products/character), keypad and USB I/O using [FT245R](http://www.ftdichip.com/Products/ICs/FT245R.htm).

<!-- more -->
Obviously native 16-bit CPU would have too many ICs and wires. Solution is to have CPU running native 4-bit data/16-bit address instruction set (Slug/4) and then have a virtual machine (SlugVM) written in Slug/4 emulating 16-bit instruction set (Slug/16). One nice property of this approach is that Slug/16 is software defined---any changes are just changes in the SlugVM. Another nice property is that virtual machine works nicely with hardware design based on [Harvard architecture](https://en.wikipedia.org/wiki/Harvard_architecture)---_read-only memory_ (ROM) is storing Slug/4 program and _random access memory_ (RAM) storing Slug/16 program and data. The downside is speed---hence the name. Emulation of some Slug/16 instructions may take hundreds of Slug/4 instructions. In Slug V1 I decided to limit Slug/4 to 12-bits address keeping in mind that extension to 16-bit must be trivial.

![](slug.png)

To simplify machine cycle I choose to have fixed length instruction set for Slug/4. Each instruction is exactly 1 byte long. There are two kinds of instructions: with immediate operand and without. In instruction without operand the entire 8 bits are the instruction code. Instruction with immediate operand is split between highest 4 bits being the instruction code and lowest 4 bits reserved for immediate operand. Machine cycle begins with _program counter_ (PC) containing the address of instruction to execute. Instruction is selected from program ROM by forming PC bits on its address inputs. PC is implemented as three cascaded 4-bit counters. PC increment enables sequential program execution. Loading new value into PC enables branching. If extension to 16-bit and 64KiB of program storage will be desired I simply add another 4-bit counter. Having 12 bit-wide address in Slug V1 will allow for 4KiB of storage for Slug/4 program---hopefully enough for the VM implementation.

To orchestrate the CPU each Slug/4 instruction is decoded into CONTROL word. CONTROL word signals all other CPU devices during machine cycle. To enable conditional branching 2 bits of FLAGS are combined with 8 bits of Slug/4 instruction to form an address for micro-code ROM. Micro-code is in essence a memory table that maps instruction code in given machine state (FLAGS) to corresponding CONTROL word. When instruction has immediate operand all 16 combinations map to the same CONTROL word. Same happens when instruction has same behavior regardless all or some bits of FLAGS. Therefore micro-code memory has many repetitions. Micro-code provides level of flexibility by allowing to define and redefine instructions without changing hardware. To signal many CPU devices CONTROL word should be wide enough. With standard EEPROM ICs working with 8 bits of data and Slug having 23 CONTROL signals I will need 3 ICs for storing micro-code.

In addition to CONTROL signals, CPU devices are interconnected with DATA bus and ADDRESS bus. Bus is a special set of nets. ([A net](https://en.wikipedia.org/wiki/Netlist) is a wire that interconnects two or more component terminals.) Usually a net has one fixed output terminal and one of more fixed input terminals. The output always drives inputs. Bus is different. In any given machine cycle only one device is selected to drive a bus---thus provide an output to all its nets. This makes bus active. When a bus is active one or more devices can be driven by it or in other words be the inputs for driver output. CONTROL signals are commonly prefixed by LD (load) when device is enabled to be driven by certain bus and by OE (output enable) when device is enabled to drive a bus. Tilde in front means that signal is inverted---zero for enabling and 1 for disabling.

_Accumulator_ (A) register, FLAGS register and _arithmetic-logic unit_ ALU along with _[multiplexer](https://en.wikipedia.org/wiki/Multiplexer)_ (MUX) and bus buffer form _execution unit_ (EU). EU interacts with the rest of CPU via DATA bus. EU operates in three modes:

* MUX is switched for ALU port B to be driven from DATA bus and ALU port A is driven from register A. _ALU mode control_ (ALUM), 4-bit _ALU function select_ (ALUS) and _carry in_ (CRIN) CONTROL signals define ALU operation to be performed on ports A and B (for example F=A+B). The result appears on port F. Port F drives back into register A for the next machine cycle. ALU operation F=B simply loads register A. In this mode DATA bus must be active and bus is driven by either instruction immediate operand or RAM. Therefore there are two flavors for every EU instruction. For example `ADD <X>` will add immediate operand X to A and store the result in A. `ADD_@C` will add 4-bit value stored in RAM at the address pointed by register C (described later) to A and store the result in A.
* ALU is executing F=A operation. Port B is ignored and port A is driven by register A. Port F is enabled to drive DATA bus. This mode is used by instructions that take value in register A and either store it in RAM or write to one of I/O ports. For example `ST_A_@C` will store 4-bit value from register A into address pointed by register C. `OUT <X>` will write value from register A to I/O port X.
* ALU is executing F=B while MUX is switched for port B to be driven by value of register A shifted by 1 bit to the right. Port F is driving back into register A. The only instruction using this mode is `ROR` that does right circular shift of register A.

When _load flags_ (LDFL) CONTROL signal is enabled ALU’s _carry out_ (CROUT) signal is joined by OR’ed output of port F--this checks for zero--(ZERO) and then loaded into FLAGS register as C and Z bits correspondingly. This is done for all instructions that involve storing the result in register A and `CMP` instructions that do subtraction without storing the result. C bit is carry out for most recent ALU operation — meaning there was overflow or underflow. Z bit is zero value most recently stored in register A or equal for `CMP` instruction. Both are used for conditional branching.

_Addressing unit_ (AU) is formed by two registers: B and C. These two registers are used to form addresses. In 12-bit Slug V1 they are subdivided into B0, B1, B2 and C0, C1, C2 4-bit partitions to enable loading from DATA bus. For 16-bit extension B3 and C3 are reserved in both CONTROL word and Slug/4. 4-bit partitions are selected by 3-bit SEL signal that is further decoded into 8 DSEL signals. Combined 12-bit drive ADDRESS bus when enabled by CONTROL word. ADDRESS bus is used to:

* Provide address in RAM for register indirect operations;
* Provide address in program ROM to be loaded in PC for branching.

Instruction size limitation of 4 bits for immediate operand means that direct addressing is not supported at all. (Fitting 12 or 16 bits would require variable length instruction set and complicate machine cycle.) Therefore every instruction that needs an address uses indirect addressing through either B or C. In order to fully load B or C Slug/4 needs 3 instructions for 12-bit address variation and 4 instructions for 16-bit address. This is where I trade-off for small and uniformly sized instruction set and for the flexibility of changing address width.

Register B is used for indirect addressing in branching (`BU_B` and others). Both registers can be used for indirect addressing in EU instructions (`ADD_@B`, `ADD_@C` and others). Both registers can be used to load register A indirectly (`LD_A_@B`, `LD_A_@C`). 4-bit partitions of both registers can be loaded from register A (`LD_B0_A` and others). In addition B can be used to indirectly load partitions of C (`LD_C0_@B` and others) and vise versa. This enables [memory indirect](https://en.wikipedia.org/wiki/Addressing_mode#Memory_indirect) addressing required for implementing pointer arithmetic.

RAM unit is formed by one or more RAM ICs. In Slug V1 I use single IC and ADDRESS bus is connected directly to its address inputs. When _chip select RAM_ (CSRAM) CONTROL signal is enabled RAM will drive DATA bus with value stored at the address driven on ADDRESS bus. When in addition to CSRAM _write enable RAM_ (WERAM) signal is enabled RAM will store values driven on DATA bus at location by address driven on ADDRESS bus.

I/O unit is formed by registers serving as output ports and bus buffers serving as input ports. I/O unit uses same DSEL signals used by AU to choose one of 8 I/O ports. `OUT` instruction is signaling EU to drive DATA bus with value of register A, which then gets stored in selected output register indefinitely. Selected input port drives DATA bus for the duration of `IN` instruction cycle while signaling EU to load register A. In Slug V1 I use 2 output ports for LCD display and 1 input port for keypad.
